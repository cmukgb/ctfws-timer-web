{% extends "base.html" %}

{% load static %}

{% block scripts %}
    <!-- ServerDate JavaScript served from the same server as this file -->
    <script src="{% static 'ServerDate.js' %}"></script>

    <!-- Inserts a <script> containing all the MQTT JavaScript common to this
         and the judges page -->
    {% include "mqtt.html" %}

    <!-- Runtime + Compiler version of Vue 2.x from CDN -->
    <!-- Use production version (vue.min.js) when deploying -->
    {% if DEBUG %}
        <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    {% else %}
        <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js"></script>
    {% endif %}

    <!-- Minified version of vuejs-storage from CDN -->
    <!-- This must be version 1.0.0 as there is a bug in 1.0.1 (the latest as of
         this writing) -->
    <script src="https://cdn.jsdelivr.net/npm/vuejs-storage@1.0.0/dist/vuejs-storage.min.js"></script>

    <script>
      {% if DEBUG %}
          "use strict";
      {% endif %}

      // TODO deleteme Timing constants
      var updateUIIntervalTime = 500; // ms

      // If useWords, then convert seconds to
      // "[minus ][H hr[s]][M min[s]]S sec[s]"
      // Otherwise, convert seconds to
      // "[-][H:]M:S"
      function toHMSHelper(time, useWords) {
        var negative = false;
        if (time < 0) {
          negative = true;
          time = time * -1;
        }

        var hours = Math.floor(time / 3600);
        time = time - hours * 3600;
        var minutes = Math.floor(time / 60);
        var seconds = time - minutes * 60;

        if (useWords) {
          var result = "";
          if (hours > 0) {
            result += hours + " hr" + (hours === 1 ? "" : "s") + " ";
          }
          if (minutes > 0) {
            result += minutes + " min" + (minutes === 1 ? "" : "s") + " ";
          }
          // Add seconds if there are any or add "0 secs" if there are no
          // hours and no minutes
          if (seconds > 0 || (minutes <= 0 && hours <= 0)) {
            result += seconds + " sec" + (seconds === 1 ? "" : "s");
          }
          return (negative ? "minus " : "") + result.trim();

        } else {
          var result = "";
          if (hours === 0) {
            result = minutes + ":" + (seconds < 10 ? "0" + seconds : seconds);
          } else {
            result =  hours + ":" + (minutes < 10 ? "0" + minutes : minutes) +
              ":" + (seconds < 10 ? "0" + seconds : seconds);
          }
          return (negative ? "-" : "") + result;

        }
      }

      // Convert seconds to "[-][H:]M:S"
      function toHMS(time) {
        return toHMSHelper(time, false);
      }

      // Convert seconds to "[minus ][H hr[s]][M min[s]]S sec[s]"
      function toHMSWords(time) {
        return toHMSHelper(time, true);
      }

      // Get the server's current Unix time in seconds
      function getServerNow() {
        return Math.round(ServerDate.now() / 1000);
      }

      // Get the client's current Unix time in seconds
      function getClientNow() {
        return Math.round(Date.now() / 1000);
      }

      // Log the ServerDate precision and delta every serverDateLogInterval
      function logServerDate() {
        var delta = ServerDate - new Date();
        console.info("ServerDate delta: " + delta + " ms = " +
          toHMS(delta / 1000));
        console.info("ServerDate precision: +/-" + ServerDate.getPrecision() +
          " ms");
      }

      // Sets the two spans which form the game header text field
      // function setGameHeader(firstText, secondText, secondClass) {
      //   $("#gameHeader1").text(firstText);
      //   $("#gameHeader2").text(secondText);
      //   $("#gameHeader2").removeClass();
      //   $("#gameHeader2").addClass(secondClass);
      // }

      // Sets the color of a progress bar
      function setBarColor(barName, color) {
        $(barName).removeClass("progress-bar-success");
        $(barName).removeClass("progress-bar-info");
        $(barName).removeClass("progress-bar-warning");
        $(barName).removeClass("progress-bar-danger");
        $(barName).addClass(color);
      }

      // UI const variables
      // var redFlagsText = "Red has: ";
      // var yellowFlagsText = "Yellow has: ";
      // var flagsText = "Total per side: ";

      // UI state variables
      //   Config
      // var gameValid = false; // whether the most recent config msg was "none"
      // var gameStarttime = 0;
      // var setupDuration = 0;
      // var numRounds = 0;
      // var roundDuration = 0;
      // var flagsPerTeam = 0;
      // var gameNumber = 0;
      //   Stun Timer
      // var stunStart = 0;
      //   Flags
      // var showFlags = true;
      // var numRedFlags = 0;
      // var numYellowFlags = 0;
      //   Endtime
      // var gameEndtime = 0;
      //   Messages
      // var gameMessages = [];

      // Function which updates the page based on the UI state variables
      function updateUI() {
        return;
        var now = getServerNow();

        // Config and Endtime
        if (gameValid) {
          // $("#flagsHeader").text(flagsText + flagsPerTeam);

          // var setupEnd = gameStarttime + setupDuration;
          // var gameEnd = setupEnd + (numRounds * roundDuration); // scheduled end
          // var gameDuration = gameEnd - setupEnd;
          // var setupEndDate = new Date(setupEnd * 1000);
          // var gameStartText = setupEndDate.toLocaleTimeString();
          // var numText = gameNumber === 0 ? "State" : gameNumber;

          if ((gameEndtime >= gameStarttime && gameEndtime <= now) ||
              gameEnd <= now) {
            // Over
            // setGameHeader("Game " + numText + ": ", "Over", "text-danger");
            var secs = 0;
            // var gameEndDate = null;
            if (gameEndtime >= gameStarttime && gameEndtime <= now) {
              secs = Math.max(Math.min(gameEndtime, gameEnd) - setupEnd, 0);
              // gameEndDate = new Date(Math.min(gameEndtime, gameEnd) * 1000);
            } else {
              secs = gameEnd - setupEnd;
              // gameEndDate = new Date(gameEnd * 1000);
            }
            // var gameEndText = gameEndDate.toLocaleTimeString();
            // $("#startTimeLabel").text("Game ended at " + gameEndText);
            var roundNum = Math.floor((secs - 1) / roundDuration); // 0-indexed
            var roundSecs = secs - roundNum * roundDuration;
            $("#setupJailbreakLabel").text("Jailbreak " + (roundNum + 1));
            var percent1 = Math.round((100 * roundSecs) / roundDuration);
            $("#firstBar").width(percent1 + "%");
            setBarColor("#firstBar", "progress-bar-danger");
            $("#firstBarLabel").text(toHMS(roundSecs) + " / " +
                toHMS(roundDuration));
            var percent2 = Math.round((100 * secs) / gameDuration);
            $("#secondBar").width(percent2 + "%");
            setBarColor("#secondBar", "progress-bar-danger");
            $("#secondBarLabel").text(toHMS(secs) + " / " +
                toHMS(gameDuration));
          } else if (setupEnd <= now) {
            // Playing
            // setGameHeader("Game " + numText + ": ", "In Progress",
            //     "text-success");
            // $("#startTimeLabel").text("Game started at " + gameStartText);
            var secs = now - setupEnd;
            var roundNum = Math.floor((secs - 1) / roundDuration); // 0-indexed
            var roundSecs = secs - roundNum * roundDuration;
            $("#setupJailbreakLabel").text("Jailbreak " + (roundNum + 1));
            var percent1 = Math.round((100 * roundSecs) / roundDuration);
            $("#firstBar").width(percent1 + "%");
            setBarColor("#firstBar", "progress-bar-warning");
            $("#firstBarLabel").text(toHMS(roundSecs) + " / " +
                toHMS(roundDuration));
            var percent2 = Math.round((100 * secs) / gameDuration);
            $("#secondBar").width(percent2 + "%");
            setBarColor("#secondBar", "progress-bar-success");
            $("#secondBarLabel").text(toHMS(secs) + " / " +
                toHMS(gameDuration));
          } else {
            // Setup
            // setGameHeader("Game " + numText + ": ", "Setup", "text-info");
            // $("#startTimeLabel").text("Game starts at " + gameStartText);
            $("#setupJailbreakLabel").text("Setup");
            var secs = now - gameStarttime;
            var percent = Math.round((100 * secs) / setupDuration);
            $("#firstBar").width(percent + "%");
            setBarColor("#firstBar", "progress-bar-info");
            $("#firstBarLabel").text(toHMS(secs) + " / " +
                toHMS(setupDuration));
            $("#secondBar").width("0%");
            setBarColor("#secondBar", "progress-bar-success");
            $("#secondBarLabel").text(toHMS(0) + " / " + toHMS(gameDuration));
          }

        } else {
          // No Game
          // setGameHeader("No Current Game", "", "");
          // $("#startTimeLabel").text("");
          $("#setupJailbreakLabel").text("Setup");
          $("#firstBar").width("0%");
          setBarColor("#firstBar", "progress-bar-danger");
          $("#firstBarLabel").text("0:00 / 15:00");
          $("#secondBar").width("0%");
          setBarColor("#secondBar", "progress-bar-danger");
          $("#secondBarLabel").text("0:00 / 1:00:00");
          // $("#flagsHeader").text(flagsText + "0");
        }

        // Stun Timer
        //if (stunStart > 0) {
          // Stun active or over
          // $("#stunRow").removeClass("hidden");
          // var stunLength = 60
          // var secs = Math.min(now - stunStart, stunLength);
          // var percent = Math.round((100 * secs) / stunLength);
          // $("#stunBar").width(percent + "%");
          // $("#stunBarLabel").text(toHMS(secs) + " / " + toHMS(stunLength));
          // if (percent < 100) {
          //   $("#cancelButton").text("Cancel");
          // } else {
          //   $("#cancelButton").text("Done");
          // }
          // $("#stunButtonRow").addClass("hidden");
          // $("#cancelButtonRow").removeClass("hidden");
        //} else {
          // No stun
          // $("#stunRow").addClass("hidden");
          // $("#cancelButtonRow").addClass("hidden");
          // $("#stunButtonRow").removeClass("hidden");
          // $("#stunBar").width("0%");
        //}

        // Flags
        // if (showFlags) {
          // $("#redFlagsHeader").text(redFlagsText + numRedFlags);
          // $("#yellowFlagsHeader").text(yellowFlagsText + numYellowFlags);
        // } else {
          // $("#redFlagsHeader").text(redFlagsText + "?");
          // $("#yellowFlagsHeader").text(yellowFlagsText + "?");
        // }

        // Messages
        // var firstRow = '<tr><th class="col-sm-2 col-xs-2">Time<\/th>' +
        //   '<th>Message<\/th><\/tr>';
        // $("#messageTable").html(firstRow);
        // for (var i = gameMessages.length - 1; i >= 0; i--) {
        //   var secs = gameMessages[i][0];
        //   var time = (new Date(secs * 1000)).toLocaleTimeString();
        //   var color = "";
        //   if (gameValid) {
        //     var setupEnd = gameStarttime + setupDuration;
        //     var gameEnd = setupEnd + (numRounds * roundDuration); // scheduled end
        //     var cutoff = 0;
        //     if (gameEndtime >= gameStarttime && gameEndtime <= now) {
        //       cutoff = Math.min(gameEndtime, gameEnd);
        //     } else {
        //       cutoff = gameEnd;
        //     }
        //     if (secs < gameStarttime) {
        //       color = "active";
        //     } else if (secs < setupEnd) {
        //       color = "info";
        //     } else if (secs < cutoff) {
        //       color = "success";
        //     } else {
        //       color = "danger";
        //     }
        //   }
          // var newRow = '<tr class="' + color + '"><td>' + time + '<\/td><td>' +
          //   gameMessages[i][1] + '<\/td><\/tr>';
          // $("#messageTable").append(newRow);
        // }
      }

      // Compare messages by timestamp such that sorting will put them in order
      // from newest to oldest
      function compareMessages(a, b) {
        return b.time - a.time;
      }

      function messageInList(msg, msgList) {
        for (var i = 0; i < msgList.length; i++) {
          if (msg.time === msgList[i].time && msg.body === msgList[i].body) {
            return true;
          }
        }
        return false;
      }

      // Called when an MQTT message arrives
      // function onMessageArrived(message) {
      //   console.info("onMessageArrived: " + message.destinationName + ": " +
      //       message.payloadString);
      //
      //   return;
      //
      //   var msg = message.payloadString;
      //   var topic = message.destinationName.substring(11);
      //   switch (topic) {
      //     case 'config':
      //       if (msg === "none") {
      //         gameValid = false;
      //       } else {
      //         var split = splitOnWhitespace(msg, 6);
      //         var start = parseInt(split[0]);
      //         var setup = parseInt(split[1]);
      //         var rounds = parseInt(split[2]);
      //         var roundlen = parseInt(split[3]);
      //         var flags = split[4];
      //         var game = split[5];
      //         if (!isNaN(start) && !isNaN(setup) && !isNaN(rounds) &&
      //             !isNaN(roundlen)) {
      //           gameStarttime = start;
      //           setupDuration = setup;
      //           numRounds = rounds;
      //           roundDuration = roundlen;
      //           flagsPerTeam = flags;
      //           gameNumber = game;
      //           gameValid = true;
      //         } else {
      //           console.error("Unknown config message: " + msg);
      //         }
      //       }
      //       break;
      //     case 'flags':
      //       if (msg === "?") {
      //         showFlags = false;
      //       } else {
      //         var split = splitOnWhitespace(msg, 2);
      //         var r = parseInt(split[0]);
      //         var y = parseInt(split[1]);
      //         if (!isNaN(r) && !isNaN(y)) {
      //           numRedFlags = r;
      //           numYellowFlags = y;
      //           showFlags = true;
      //         } else {
      //           console.error("Unknown flag message: " + msg);
      //         }
      //       }
      //       break;
      //     case 'endtime':
      //       var secs = parseInt(msg);
      //       if (!isNaN(secs)) {
      //         gameEndtime = secs;
      //       } else {
      //         colsole.log("Unknown endtime message: " + msg);
      //       }
      //       break;
      //     case 'message':
      //     case 'message/player':
      //       var split = splitOnFirstWhitespace(msg);
      //       var secs = parseInt(split[0]);
      //       var body = split[1];
      //       if (!isNaN(secs)) {
      //         if (!messageInList([secs, body], gameMessages)) {
      //           gameMessages.push([secs, body]);
      //           gameMessages = gameMessages.sort(compareMessages);
      //         }
      //       } else {
      //         console.error("Unknown message message: " + msg);
      //       }
      //       break;
      //     case 'message/jail':
      //       console.info("Ignoring jail message: " + msg);
      //       break;
      //     default:
      //       console.warn("Unknown topic: " + message.destinationName);
      //   }
      //
      //   updateUI();
      //   // If it took more than 3 seconds to get here this interval will
      //   // already be set up. Otherwise, start it now.
      //   if (updateUIIntervalObject === false) {
      //     updateUIIntervalObject = setInterval(updateUI, updateUIIntervalTime);
      //   }
      // }

      // Constants
      var updateNowIntervalTime = 500; // ms
      var clockOffsetThreshold = 15; // seconds
      var serverDateLogInterval = 60 * 1000; // ms

      // TODO deleteme
      var updateUIIntervalObject = false;

      $(document).ready(function() {
        // Log the ServerDate precision and delta
        logServerDate();
        setInterval(logServerDate, serverDateLogInterval);

        // TODO figure out if something like this is still needed
        // The UI looks cleanest if we don't update it until the MQTT client
        // has connected. So we give it 3 seconds connect before we set up the
        // UI interval. If it connects first, the below variable will still be
        // false and it will set up the interval. If not, we start the interval
        // and if it still connects after 3 seconds, it will not touch the
        // interval.
        updateUIIntervalObject = false; // Intentionally global
        setTimeout(function() {
          if (updateUIIntervalObject === false) {
            updateUI();
            updateUIIntervalObject = setInterval(updateUI, updateUIIntervalTime);
          }
        }, 3 * 1000); // 3 seconds

        Vue.use(vuejsStorage);

        // Unless otherwise noted, all durations are in stored in seconds and
        // all times are stored as seconds since the UNIX epoch
        new Vue({
          el: '#app',
          delimiters: ['[[', ']]'],
          data: {
            serverNow: getServerNow(),
            clientNow: getClientNow(),
            // Whether the most recent config message was not "none"
            // Defaults to null (and is only ever set to null here), so if it's
            // null, then we haven't gotten a config message yet.
            displayGame: null,
            gameNumber: 0,
            times: {
              start: 0,
              earlyGameEnd: 0, // Time of game end if ended before schduled
            },
            rounds: {
              // Number of jailbreaks. Set by the broker but always should be 4.
              total: 4,
              // Jailbreak length in secs. Also set by broker but always 15 min.
              duration: 15 * 60,
            },
            // Setup length in secs. Also set by broker but always 15 min.
            setupDuration: 15 * 60,
            stun: {
              start: 0,
              length: 60, // Fixed total length of stun
            },
            flags: {
              show: true,
              numRed: 0,
              numYellow: 0,
              perTeam: 0,
            },
          },
          // Used by vuejs-storage: Everything in this.storage.data should work
          // exactly the same as things in this.data (including being available
          // just as this.foo), except data in storage will persist accross page
          // loads, until the browser is restarted (see window.sessionStorage).
          storage: {
            data: {
              messages: [],
            },
            storage: sessionStorage,
            namespace: 'ctfws-timer',
          },
          created: function() {
            // Setup the MQTT client and connect. This function is defined in
            // mqtt.html, which is included above. This defines mqttClient as the
            // global variable for the client connection.
            initMqtt(this.onMessageArrived);

            // Update the "now" variables every updateNowIntervalTime. Vue will
            // react to this change and update all UI that uses them.
            var vm = this;
            setInterval(function() {
              vm.serverNow = getServerNow();
              vm.clientNow = getClientNow();
            }, updateNowIntervalTime);
          },
          computed: {
            serverClientDelta: function() {
              return this.serverNow - this.clientNow;
            },
            serverClientAbsDelta: function() {
              return Math.abs(this.serverClientDelta);
            },
            showOffset: function() {
              // Check if the server time is different from the client time by
              // more than clockOffsetThreshhold seconds. If so, warn the user.
              return this.serverClientAbsDelta > clockOffsetThreshold;
            },
            now: function() {
              return this.serverNow;
            },
            gameNumberText: function() {
              // The CtFwS MQTT spec says a game number of 0 "may be
              // interpreted as suppressing indication in the client"
              return this.gameNumber === 0 ? "State" : this.gameNumber;
            },
            setupEnd: function() {
              return this.times.start + this.setupDuration;
            },
            gameDuration: function() {
              return this.rounds.total * this.rounds.duration;
            },
            scheduledGameEnd: function() {
              return this.setupEnd + this.gameDuration;
            },
            actualGameEnd: function() {
              if (this.times.earlyGameEnd >= this.times.start) {
                return Math.min(this.times.earlyGameEnd, this.scheduledGameEnd);
              } else {
                return this.scheduledGameEnd;
              }
            },
            gameState: function() {
              if (this.now >= this.actualGameEnd) {
                return {
                  stateText: "Over",
                  stateColor: "text-danger",
                  subtitleText: "ended",
                  subtitleTime: this.actualGameEnd,
                };
              } else if (this.now >= this.setupEnd) {
                return {
                  stateText: "In Progress",
                  stateColor: "text-success",
                  subtitleText: "started",
                  subtitleTime: this.setupEnd,
                };
              } else if (this.now >= this.times.start) {
                return {
                  stateText: "Setup",
                  stateColor: "text-info",
                  subtitleText: "starts",
                  subtitleTime: this.setupEnd,
                };
              } else {
                return {
                  stateText: "Pre-Setup",
                  stateColor: "text-muted",
                  subtitleText: "starts",
                  subtitleTime: this.setupEnd,
                };
              }
            },
            stunElapsed: function() {
              return Math.min(this.now - this.stun.start, this.stun.length);
            },
            stunPercent: function() {
              return Math.round((100 * this.stunElapsed) / this.stun.length);
            },
            sortedMessages: function() {
              return this.messages.sort(compareMessages);
            },
          },
          methods: {
            clickStun: function() {
              console.info("onStunButtonClick");
              this.stun.start = this.now;
            },
            clickCancel: function() {
              console.info("onCancelButtonClick");
              this.stun.start = 0;
            },
            onMessageArrived: function(message) {
              console.info("onMessageArrived: " + message.destinationName +
                  ": " + message.payloadString);

              var msg = message.payloadString;
              var topic = message.destinationName.substring(
                  "ctfws/game/".length);
              switch (topic) {
                case 'config':
                  if (msg === "none") {
                    this.displayGame = false;
                  } else {
                    var split = splitOnWhitespace(msg, 6);
                    var start = parseInt(split[0]);
                    var setup = parseInt(split[1]);
                    var rounds = parseInt(split[2]);
                    var roundlen = parseInt(split[3]);
                    var flags = split[4];
                    var gamenum = split[5];
                    if (!isNaN(start) && !isNaN(setup) && !isNaN(rounds) &&
                        !isNaN(roundlen)) {
                      this.times.start = start;
                      this.setupDuration = setup;
                      this.rounds.total = rounds;
                      this.rounds.duration = roundlen;
                      this.flags.perTeam = flags;
                      this.gameNumber = gamenum;
                      this.displayGame = true;
                    } else {
                      console.error("Unknown config message: " + msg);
                    }
                  }
                  break;
                case 'flags':
                  if (msg === "?") {
                    this.flags.show = false;
                  } else {
                    var split = splitOnWhitespace(msg, 2);
                    var r = parseInt(split[0]);
                    var y = parseInt(split[1]);
                    if (!isNaN(r) && !isNaN(y)) {
                      this.flags.numRed = r;
                      this.flags.numYellow = y;
                      this.flags.show = true;
                    } else {
                      console.error("Unknown flag message: " + msg);
                    }
                  }
                  break;
                case 'endtime':
                  var secs = parseInt(msg);
                  if (!isNaN(secs)) {
                    this.times.earlyGameEnd = secs;
                  } else {
                    colsole.log("Unknown endtime message: " + msg);
                  }
                  break;
                case 'message':
                case 'message/player':
                  var split = splitOnFirstWhitespace(msg);
                  var secs = parseInt(split[0]);
                  var body = split[1];
                  if (!isNaN(secs)) {
                    var newMessage = { time: secs, body: body };
                    if (secs === 1) {
                      // Somewhat "hidden" feature to force clients to clear
                      // their message list in case the judge really needs to
                      // recall a message. If secs is exactly 1, the list is
                      // cleared and the message is ignored.
                      this.messages = []
                    } else if (!messageInList(newMessage, this.messages)) {
                      this.messages.push(newMessage);
                    }
                  } else {
                    console.error("Unknown message message: " + msg);
                  }
                  break;
                case 'message/jail':
                  console.info("Ignoring jail message: " + msg);
                  break;
                default:
                  console.warn("Unknown topic: " + message.destinationName);
              }
            },
            // Get the color class to apply to a message in the table given it's
            // timestamp
            toMessageColor: function(timestamp) {
              if (this.displayGame) {
                if (timestamp >= this.actualGameEnd) {
                  return "danger"; // Red, game over
                } else if (timestamp >= this.setupEnd) {
                  return "success"; // Green, playing
                } else if (timestamp >= this.times.start) {
                  return "info"; // Blue, setup
                } else {
                  return "active"; // Grey, before setup
                }
              } else {
                return "";
              }
            },
          },
          filters: {
            toHMS: toHMS,
            toHMSWords: toHMSWords,
            secsToLocaleTimeString: function(secs) {
              return new Date(secs * 1000).toLocaleTimeString();
            },
          },
          mounted: function() {
            // All initial jQuery needs to be done in here, after Vue has set up
            // the DOM

            // Mobile Safari has a bug that prevents popovers from closing when
            // the user taps away from them. This can be fixed with the below
            // CSS, but we only want to do this when needed because if the
            // device does have a mouse, it makes the mouse always the
            // "clickable" style pointer.
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) &&
                !window.MSStream) {
              $("body").css("cursor", "pointer");
            }

            // Enable the popover on the "What's this?" shown when there is a
            // clock offset.
            $("#offsetPopover").popover();
          },
        });

        console.info("Finished setup");
      });
    </script>
{% endblock %}

{% block page_title %}
    <span v-if="displayGame === null">
      Connecting...
    </span>
    <span v-else-if="displayGame">
      Game [[ gameNumberText ]]:
      <span :class="gameState.stateColor">[[ gameState.stateText ]]</span>
    </span>
    <span v-else>
      No Current Game
    </span>
{% endblock %}

{% block container %}
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">

        <p class="lead text-center">
          <span v-if="displayGame">
            Game [[ gameState.subtitleText ]] at
            [[ gameState.subtitleTime | secsToLocaleTimeString ]]
          </span>
        </p>

        <p v-show="showOffset" class="text-muted text-center">
          <strong>Note:</strong> Your clock is
          [[ this.serverClientDelta > 0 ? 'behind' : 'ahead of' ]]
          the game's by [[ serverClientAbsDelta | toHMSWords ]].
          <a id="offsetPopover" tabindex="0" role="button"
            data-toggle="popover" data-trigger="focus" data-placement="auto"
            data-html="data-html" data-content=
            "We correct for any difference between your clock
            and the game clock, so you donâ€™t have to do anything for the app
            to work.
            <br>
            However, we still display the game start time and any messages
            using the game clock. Because your clock is off by more than a
            few seconds, this means the times shown may not agree with the
            clock shown on your device."
            >
            What's&nbsp;this?
          </a>
        </p>

      </div>

    </div>
    <!-- TODO deleteme? <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
      </div>

    </div> -->
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-2 col-xs-3">
        <p id="setupJailbreakLabel" class="lead text-center">Setup</p>
      </div>

      <div class="col-sm-6 col-xs-6">
        <div class="progress">
          <div id="firstBar" class="progress-bar" role="progressbar"
            style="width: 0%">
          </div>
        </div>
      </div>

      <div class="col-sm-2 col-xs-3">
        <p id="firstBarLabel" class="lead text-center">0:00 / 15:00</p>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-2 col-xs-3">
        <p class="lead text-center">Game Time Elapsed</p>
      </div>

      <div class="col-sm-6 col-xs-6">
        <div class="progress">
          <div id="secondBar" class="progress-bar" role="progressbar"
            style="width: 0%">
          </div>
        </div>
      </div>

      <div class="col-sm-2 col-xs-3">
        <p id="secondBarLabel" class="lead text-center">0:00 / 1:00:00</p>
      </div>

    </div>
    <div v-if="stun.start > 0" class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-2 col-xs-3">
        <p class="lead text-center">Stun Timer</p>
      </div>

      <div class="col-sm-6 col-xs-6">
        <div class="progress">
          <div class="progress-bar progress-bar-info"
            role="progressbar" :style="{ width: stunPercent + '%' }">
          </div>
        </div>
      </div>

      <div class="col-sm-2 col-xs-3">
        <p class="lead text-center">
          [[ stunElapsed | toHMS ]] / [[ stun.length | toHMS ]]
        </p>
      </div>

    </div>
    <div v-if="stun.start > 0" class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12 text-center">
        <button class="btn btn-info btn-lg" type="button"
          @click="clickCancel">
          [[ stunPercent < 100 ? 'Cancel' : 'Done' ]]
        </button>
      </div>

    </div>
    <div v-else class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12 text-center">
        <button class="btn btn-info btn-lg" type="button"
          @click="clickStun">
          Stun Timer
        </button>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <div class="page-header">
          <h2 class="text-center">Flags</h2>
        </div>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <p class="text-muted text-center">
          Note: The head judge may choose to report a score for each team
          rather than a number of flags.
        </p>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <h3 class="text-center">
          Total per side: [[ displayGame ? flags.perTeam : 0 ]]
        </h3>
      </div>

    </div>
    <div v-if="flags.show" class="row vertical-center">

        <div class="col-sm-offset-1 col-sm-5 col-xs-6">
          <h3 class="text-center text-danger">
            Red has: [[ flags.numRed ]]
          </h3>
        </div>

        <div class="col-sm-5 col-xs-6">
          <h3 class="text-center text-warning">
            Yellow has: [[ flags.numYellow ]]
          </h3>
        </div>

    </div>
    <div v-else class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <h3 class="text-center text-info">
          Team scores hidden
        </h3>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <div class="page-header">
          <h2 class="text-center">Messages</h2>
        </div>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <p>
        <strong>Note:</strong> Messages sent while the browser is inactive may not appear.
        <br>
        Messages sent before game start are
        <span class="text-muted">grey</span>, during setup are
        <span class="text-info">blue</span>, during game play are
        <span class="text-success">green</span>, and after game end are
        <span class="text-danger">red</span>.
        </p>
      </div>

    </div>
    <div class="row vertical-center">

      <div class="col-sm-offset-1 col-sm-10 col-xs-12">
        <table class="table">
          <tr>
            <th class="col-sm-2 col-xs-2">Time</th>
            <th>Message</th>
          </tr>
          <tr v-for="message in sortedMessages"
            :key="message.time + '|' + message.body"
            :class="toMessageColor(message.time)">
            <td>[[ message.time | secsToLocaleTimeString ]]</td>
            <td>[[ message.body ]]</td>
          </tr>
        </table>
      </div>

    </div>
{% endblock %}
